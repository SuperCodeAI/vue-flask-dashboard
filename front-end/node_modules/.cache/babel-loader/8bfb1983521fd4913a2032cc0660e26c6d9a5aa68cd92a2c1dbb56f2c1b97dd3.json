{"ast":null,"code":"import { ref, computed, onMounted } from \"vue\";\nimport { useStore } from \"vuex\";\nexport default {\n  __name: 'NodeSelector',\n  props: {\n    modelValue: {\n      type: Array,\n      default: () => [] // Provide a default empty array\n    }\n  },\n  emits: [\"update:modelValue\"],\n  setup(__props, {\n    expose: __expose,\n    emit: __emit\n  }) {\n    __expose();\n    const store = useStore();\n    const isActive = node => {\n      return node.status === 1; // 가정: status 1이 '학습중'을 의미\n    };\n    const nodes = computed(() => {\n      const unsortedNodes = store.getters.userNodes || [];\n      return unsortedNodes.sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically by name\n    });\n    const props = __props;\n    const isNodeSelected = node => {\n      return props.modelValue.some(selectedNode => selectedNode.node_id === node.node_id);\n    };\n    const emit = __emit;\n    onMounted(async () => {\n      await store.dispatch(\"fetchNodes\"); // 노드 정보 가져와서 마운트하기.\n    });\n    const selectedNode = ref(null);\n    const toggleNodeSelection = node => {\n      if (node.status !== 0) {\n        // If the node is not in a waiting state, display its details without selecting it\n        selectedNode.value = node;\n        console.error(\"Node is not in a waiting state and cannot be selected.\");\n        return; // Exit early without changing the selection\n      }\n      const isSelected = props.modelValue.some(selectedNode => selectedNode.node_id === node.node_id);\n      let newSelectedNodes = isSelected ? props.modelValue.filter(selectedNode => selectedNode.node_id !== node.node_id) : [...props.modelValue, node];\n      emit(\"update:modelValue\", newSelectedNodes);\n\n      // Set or unset the selectedNode for displaying details\n      selectedNode.value = isSelected ? null : node;\n    };\n    const nodeStatusDescription = status => {\n      const statusMap = {\n        0: \"대기중\",\n        1: \"학습중\",\n        2: \"학습완료\"\n      };\n      return statusMap[status] || \"Unknown status\";\n    };\n    const sortedSelectedNodes = computed(() => {\n      if (!Array.isArray(props.modelValue)) {\n        return []; // Return an empty array if props.modelValue is not an array\n      }\n      // Proceed with sorting if props.modelValue is an array\n      return [...props.modelValue].sort((a, b) => a.name.localeCompare(b.name));\n    });\n    const __returned__ = {\n      store,\n      isActive,\n      nodes,\n      props,\n      isNodeSelected,\n      emit,\n      selectedNode,\n      toggleNodeSelection,\n      nodeStatusDescription,\n      sortedSelectedNodes,\n      ref,\n      computed,\n      onMounted,\n      get useStore() {\n        return useStore;\n      }\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ref","computed","onMounted","useStore","store","isActive","node","status","nodes","unsortedNodes","getters","userNodes","sort","a","b","name","localeCompare","props","__props","isNodeSelected","modelValue","some","selectedNode","node_id","emit","__emit","dispatch","toggleNodeSelection","value","console","error","isSelected","newSelectedNodes","filter","nodeStatusDescription","statusMap","sortedSelectedNodes","Array","isArray"],"sources":["D:/develop/vue-flask-dashboard/front-end/src/views/components/NodeSelector.vue"],"sourcesContent":["<template>\n  <div class=\"node-selector-container\">\n    <div class=\"node-header\">\n      <h2>Node Selection</h2>\n    </div>\n    <div class=\"node-content\">\n      <div class=\"node-list\">\n        <ul>\n          <li\n            v-for=\"node in nodes\"\n            :key=\"node.id\"\n            @click=\"toggleNodeSelection(node)\"\n            :class=\"{ 'node-active': isActive(node), selected: isNodeSelected(node) }\"\n          >\n            {{ node.name }}\n          </li>\n        </ul>\n      </div>\n\n      <div class=\"node-description\" v-if=\"selectedNode\">\n        <h4>{{ selectedNode.name }} 설명</h4>\n        <p>CPU Core Count: {{ selectedNode.cpu_core_count }}</p>\n        <p>Total Memory: {{ selectedNode.total_memory_mb }} MB</p>\n        <p>Total Disk: {{ selectedNode.total_disk_mb }} MB</p>\n        <p>Status: {{ nodeStatusDescription(selectedNode.status) }}</p>\n        <p v-if=\"selectedNode.instance\">\n          Instance: {{ selectedNode.instance }}\n        </p>\n        <p v-if=\"selectedNode.gpu_info\">\n          GPU Info: {{ selectedNode.gpu_info }}\n        </p>\n      </div>\n      <div class=\"node-description\" v-else>\n        <p>Select a node to see its description.</p>\n      </div>\n\n      <!-- List of selected nodes on the far right -->\n      <div class=\"selected-nodes\">\n        <h3>Selected Nodes</h3>\n        <ul>\n          <li v-for=\"node in sortedSelectedNodes\" :key=\"node.id\">\n            {{ node.name }}\n          </li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, defineProps, defineEmits, computed, onMounted } from \"vue\";\nimport { useStore } from \"vuex\";\n\nconst store = useStore();\n\nconst isActive = (node) => {\n  return node.status === 1; // 가정: status 1이 '학습중'을 의미\n};\n\nconst nodes = computed(() => {\n  const unsortedNodes = store.getters.userNodes || [];\n  return unsortedNodes.sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically by name\n});\n\nconst props = defineProps({\n  modelValue: {\n    type: Array,\n    default: () => [], // Provide a default empty array\n  },\n});\n\nconst isNodeSelected = (node) => {\n  return props.modelValue.some(\n    (selectedNode) => selectedNode.node_id === node.node_id,\n  );\n};\n\nconst emit = defineEmits([\"update:modelValue\"]);\n\nonMounted(async () => {\n  await store.dispatch(\"fetchNodes\"); // 노드 정보 가져와서 마운트하기.\n});\n\nconst selectedNode = ref(null);\n\nconst toggleNodeSelection = (node) => {\n  if (node.status !== 0) {\n    // If the node is not in a waiting state, display its details without selecting it\n    selectedNode.value = node;\n    console.error(\"Node is not in a waiting state and cannot be selected.\");\n    return; // Exit early without changing the selection\n  }\n\n  const isSelected = props.modelValue.some(\n    (selectedNode) => selectedNode.node_id === node.node_id,\n  );\n  let newSelectedNodes = isSelected\n    ? props.modelValue.filter(\n        (selectedNode) => selectedNode.node_id !== node.node_id,\n      )\n    : [...props.modelValue, node];\n\n  emit(\"update:modelValue\", newSelectedNodes);\n\n  // Set or unset the selectedNode for displaying details\n  selectedNode.value = isSelected ? null : node;\n};\n\nconst nodeStatusDescription = (status) => {\n  const statusMap = {\n    0: \"대기중\",\n    1: \"학습중\",\n    2: \"학습완료\",\n  };\n  return statusMap[status] || \"Unknown status\";\n};\n\nconst sortedSelectedNodes = computed(() => {\n  if (!Array.isArray(props.modelValue)) {\n    return []; // Return an empty array if props.modelValue is not an array\n  }\n  // Proceed with sorting if props.modelValue is an array\n  return [...props.modelValue].sort((a, b) => a.name.localeCompare(b.name));\n});\n</script>\n\n<style scoped>\n.node-selector-container {\n  display: flex; /* Flexbox 레이아웃을 사용하여 자식 요소들을 유연하게 배치합니다. */\n  flex-direction: column; /* 자식 요소들을 수직 방향으로 정렬합니다. */\n  border: 1px solid #e0e0e0; /* 경계선을 설정하여 시각적 구분을 명확하게 합니다. */\n  background-color: #fff; /* 배경색을 흰색으로 설정하여 내용이 돋보이게 합니다. */\n  border-radius: 12px; /* 모서리를 둥글게 처리하여 부드러운 느낌을 줍니다. */\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 그림자를 추가하여 입체감을 강조합니다. */\n  overflow: hidden; /* 내용이 컨테이너를 벗어날 경우 숨깁니다. */\n}\n\n.node-header {\n  padding: 15px 20px; /* 헤더 내부에 여백을 추가하여 내용과 경계의 분리를 명확하게 합니다. */\n  background-color: #f8f8f8; /* 배경색을 연한 회색으로 설정하여 시각적 편안함을 제공합니다. */\n  text-align: left; /* 텍스트를 왼쪽으로 정렬합니다. */\n  font-size: 20px; /* 글꼴 크기를 크게 설정하여 헤더의 중요성을 강조합니다. */\n  font-weight: 600; /* 글꼴 두께를 높여 텍스트를 두드러지게 합니다. */\n  color: #333; /* 글꼴 색상을 어두운 회색으로 설정하여 가독성을 높입니다. */\n  border-bottom: 1px solid #ddd; /* 하단에 경계선을 추가하여 내용 구분을 명확히 합니다. */\n}\n\n.node-content {\n  display: flex; /* Flexbox 레이아웃을 사용하여 하위 요소들을 유연하게 배치합니다. */\n  flex-wrap: wrap; /* 컨텐츠가 넘치면 다음 줄로 자동으로 이동하도록 설정합니다. */\n}\n\n.node-list,\n.node-description,\n.selected-nodes {\n  padding: 0px; /* 패딩 제거*/\n  flex-basis: 33.3333%; /* 세 영역 모두 컨테이너 너비의 1/3을 차지하도록 설정합니다. */\n  flex-grow: 1; /* 각 영역이 균등하게 공간을 차지하도록 설정합니다. */\n  border-right: 1px solid #ddd; /* 오른쪽에 경계선을 추가하여 각 영역을 시각적으로 구분합니다. */\n}\n\n.node-list li.node-active {\n  background-color: #ffc107; /* 활성 노드 배경색을 황금색으로 설정 */\n  color: #333; /* 텍스트 색상을 어두운 회색으로 설정 */\n  font-weight: bold; /* 텍스트를 굵게 설정 */\n  cursor: not-allowed; /* 클릭 불가능 상태를 나타내는 마우스 커서 */\n}\n\n.node-list li.node-active:hover {\n  background-color: #ffc107; /* 호버 시에도 배경색을 유지 */\n}\n\n.node-list ul,\n.selected-nodes ul {\n  list-style-type: none; /* 기본 리스트 스타일을 제거합니다. */\n  padding: 0; /* 내부 여백을 제거합니다. */\n  margin: 0; /* 외부 여백을 제거합니다. */\n}\n\n.node-list li,\n.selected-nodes li {\n  padding: 10px; /* 각 항목에 패딩을 추가하여 터치 용이성을 높입니다. */\n  cursor: pointer; /* 마우스 포인터를 손가락 모양으로 변경하여 클릭 가능함을 나타냅니다. */\n  border-bottom: 1px solid #eee; /* 각 항목 하단에 경계선을 추가하여 구분을 명확하게 합니다. */\n  transition: background-color 0.3s; /* 배경색 변경에 애니메이션 효과를 추가합니다. */\n  font-size: 16px; /* 글꼴 크기를 설정하여 가독성을 높입니다. */\n  color: #333; /* 글꼴 색상을 설정하여 명확한 표시를 제공합니다. */\n}\n\n.node-list li:hover,\n.node-list li.selected,\n.selected-nodes li:hover {\n  background-color: #e3f2fd; /* 항목을 호버하거나 선택했을 때 배경색을 변경하여 시각적으로 표시합니다. */\n}\n\n/* 마지막 메인 컨텐츠 요소의 경계선 제거 */\n.selected-nodes {\n  border-right: none;\n}\n\n/* 반응형 스타일링: 화면이 작을 때 */\n@media (max-width: 768px) {\n  .node-content {\n    flex-direction: column; /* 컨텐츠를 수직으로 쌓습니다. */\n  }\n\n  .node-list,\n  .node-description,\n  .selected-nodes {\n    border-right: none; /* 경계선을 제거합니다. */\n    border-bottom: 1px solid #ddd; /* 하단에 경계선을 추가하여 각 영역을 구분합니다. */\n    flex-basis: auto; /* 각 영역의 기본 크기를 자동으로 설정합니다. */\n  }\n\n  .selected-nodes {\n    border-bottom: none; /* 마지막 영역의 하단 경계선을 제거합니다. */\n  }\n}\n</style>\n"],"mappings":"AAkDA,SAASA,GAA6B,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,KAAK;AACxE,SAASC,QAAQ,QAAQ,MAAM;;;;;;;;;;;;;;;IAE/B,MAAMC,KAAK,GAAGD,QAAQ,CAAC,CAAC;IAExB,MAAME,QAAQ,GAAIC,IAAI,IAAK;MACzB,OAAOA,IAAI,CAACC,MAAM,KAAK,CAAC,CAAC,CAAC;IAC5B,CAAC;IAED,MAAMC,KAAK,GAAGP,QAAQ,CAAC,MAAM;MAC3B,MAAMQ,aAAa,GAAGL,KAAK,CAACM,OAAO,CAACC,SAAS,IAAI,EAAE;MACnD,OAAOF,aAAa,CAACG,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,IAAI,CAACC,aAAa,CAACF,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;IACrE,CAAC,CAAC;IAEF,MAAME,KAAK,GAAGC,OAKZ;IAEF,MAAMC,cAAc,GAAIb,IAAI,IAAK;MAC/B,OAAOW,KAAK,CAACG,UAAU,CAACC,IAAI,CACzBC,YAAY,IAAKA,YAAY,CAACC,OAAO,KAAKjB,IAAI,CAACiB,OAClD,CAAC;IACH,CAAC;IAED,MAAMC,IAAI,GAAGC,MAAkC;IAE/CvB,SAAS,CAAC,YAAY;MACpB,MAAME,KAAK,CAACsB,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC;IACtC,CAAC,CAAC;IAEF,MAAMJ,YAAY,GAAGtB,GAAG,CAAC,IAAI,CAAC;IAE9B,MAAM2B,mBAAmB,GAAIrB,IAAI,IAAK;MACpC,IAAIA,IAAI,CAACC,MAAM,KAAK,CAAC,EAAE;QACrB;QACAe,YAAY,CAACM,KAAK,GAAGtB,IAAI;QACzBuB,OAAO,CAACC,KAAK,CAAC,wDAAwD,CAAC;QACvE,OAAO,CAAC;MACV;MAEA,MAAMC,UAAU,GAAGd,KAAK,CAACG,UAAU,CAACC,IAAI,CACrCC,YAAY,IAAKA,YAAY,CAACC,OAAO,KAAKjB,IAAI,CAACiB,OAClD,CAAC;MACD,IAAIS,gBAAgB,GAAGD,UAAU,GAC7Bd,KAAK,CAACG,UAAU,CAACa,MAAM,CACpBX,YAAY,IAAKA,YAAY,CAACC,OAAO,KAAKjB,IAAI,CAACiB,OAClD,CAAC,GACD,CAAC,GAAGN,KAAK,CAACG,UAAU,EAAEd,IAAI,CAAC;MAE/BkB,IAAI,CAAC,mBAAmB,EAAEQ,gBAAgB,CAAC;;MAE3C;MACAV,YAAY,CAACM,KAAK,GAAGG,UAAU,GAAG,IAAI,GAAGzB,IAAI;IAC/C,CAAC;IAED,MAAM4B,qBAAqB,GAAI3B,MAAM,IAAK;MACxC,MAAM4B,SAAS,GAAG;QAChB,CAAC,EAAE,KAAK;QACR,CAAC,EAAE,KAAK;QACR,CAAC,EAAE;MACL,CAAC;MACD,OAAOA,SAAS,CAAC5B,MAAM,CAAC,IAAI,gBAAgB;IAC9C,CAAC;IAED,MAAM6B,mBAAmB,GAAGnC,QAAQ,CAAC,MAAM;MACzC,IAAI,CAACoC,KAAK,CAACC,OAAO,CAACrB,KAAK,CAACG,UAAU,CAAC,EAAE;QACpC,OAAO,EAAE,CAAC,CAAC;MACb;MACA;MACA,OAAO,CAAC,GAAGH,KAAK,CAACG,UAAU,CAAC,CAACR,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,IAAI,CAACC,aAAa,CAACF,CAAC,CAACC,IAAI,CAAC,CAAC;IAC3E,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}